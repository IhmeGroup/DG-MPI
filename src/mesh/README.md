## `mesh`

The `mesh` directory contains the definition of the Mesh class along with
namespace MeshTools. The Mesh class is responsible for reading in the mesh file
(after it has been converted to the HDF5 file), partitioning the mesh to the
different ranks, and populating the Kokkos Views with this data.

Some things to note:

1. The mesh is read in by every rank in serial, then partitioned, and only the
   partition that the current rank needs is stored. This is no different
   than reading in the mesh on one rank then distributing (since the other
   ranks will be idle during that time). A better implementation is to read
   in portions of the mesh, then partition in parallel with ParMetis, but
   this is more work and was decided against since it is not necessary (it
   takes a huge mesh to make the mesh file not fit on a node).

2. When dealing with IDs, it is important to keep in mind whether the ID is
   local or global. Local refers to the ID on this rank, whereas global
   refers to the ID on the whole mesh. For example, if a mesh has four
   elements and you have two ranks, partitioning into two elements per rank
   results in the global IDs [0, 1, 2, 3] and local IDs [0, 1] on each rank.
   The same system exists for nodes and faces. The local-to-global views
   help convert from one to the other.

3. The View containing the interior faces contains the ghost faces as well.
   This was originally done to simplify the fluxes later, but actually a
   faster implementation is to compute the local fluxes (on faces not
   including ghosts) concurrent with the communication step - in this case,
   ghost faces should be removed from interior faces. This was not done for
   simplicity (requires some asynchronous MPI).

4. There are a fair amount of warnings generated by the Mesh class when
   compiled on GPUs. This is because it contains lots of C++ standard
   library code (vectors, etc.) that were there from before Kokkos was
   added. These containers are mainly used in the mesh reading step. A
   better implementation that would get rid of the warnings would be to add
   a separate mesh reader class (or just functions) which are pure CPU code,
   which then populates a Mesh class that contains only Kokkos views. This
   would surpress the warnings - however, there was no loss of functionality
   or breaking problems with the current implementation, so it was never
   changed.

5. Boundary faces are not implemented. They are read in from the HDF5 file,
   but not stored in Kokkos Views or used elsewhere in the simulation. The
   storage of boundary information in Kokkos requires some thought, since
   each simulation has a different number of boundary groups and each group
   has a different number of faces, which is a "jagged" data layout. Jagged
   Views are not supported in general, but there is a way to fake it by
   using an array of Views. An example of this is `ghost_faces`. The main
   thing to remember when doing this is that the destructor of each View in
   the array needs to be called explicitly (look at Mesh::Finalize to see
   what I mean).

The usage of the different Views in Mesh are well commented in Mesh.h. It is
recommended to focus on the comments for the Kokkos containers (further down in
Mesh.h) and not to focus on the comments for the C++ containers, since those are
only used to read the file in, not used elsewhere in the simulation (indeed,
they cannot be accessed later, since accessing a Vector on a GPU does not work).
